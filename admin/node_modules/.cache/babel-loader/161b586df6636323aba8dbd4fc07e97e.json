{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\nconst getAggregationValueWrappedValueGetter = _ref => {\n  let {\n    value: valueGetter,\n    getCellAggregationResult\n  } = _ref;\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n    return params.row[params.field];\n  };\n  return wrappedValueGetter;\n};\nconst getAggregationValueWrappedValueFormatter = _ref2 => {\n  let {\n    value: valueFormatter,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref2;\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n    return params.value;\n  };\n  return wrappedValueFormatter;\n};\nconst getAggregationValueWrappedRenderCell = _ref3 => {\n  let {\n    value: renderCell,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref3;\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n        return params.formattedValue;\n      }\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n    return renderCell(params);\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Skips the filtering for aggregated rows\n */\nconst getWrappedFilterOperators = _ref4 => {\n  let {\n    value: filterOperators,\n    getCellAggregationResult\n  } = _ref4;\n  return filterOperators.map(operator => {\n    return _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n        if (!originalFn) {\n          return null;\n        }\n        return params => {\n          if (getCellAggregationResult(params.id, params.field) != null) {\n            return true;\n          }\n          return originalFn(params);\n        };\n      }\n    });\n  });\n};\n\n/**\n * Add the aggregation method around the header name\n */\nconst getWrappedRenderHeader = _ref5 => {\n  let {\n    value: renderHeader,\n    aggregationRule\n  } = _ref5;\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\nexport const wrapColumnWithAggregationValue = _ref6 => {\n  let {\n    column,\n    apiRef,\n    aggregationRule\n  } = _ref6;\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$parent, _gridAggregationLooku, _gridAggregationLooku2;\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n    if (cellAggregationPosition == null) {\n      return null;\n    }\n\n    // TODO: Add custom root id\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)) == null ? void 0 : (_gridAggregationLooku2 = _gridAggregationLooku[groupId]) == null ? void 0 : _gridAggregationLooku2[field];\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n    return aggregationResult;\n  };\n  const aggregationWrappedProperties = {};\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n  return wrappedColumn;\n};\n\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\nexport const unwrapColumnFromAggregation = _ref7 => {\n  let {\n    column\n  } = _ref7;\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n  if (originalProperties.length === 0) {\n    return column;\n  }\n  const unwrappedColumn = _extends({}, column);\n  originalProperties.forEach(_ref8 => {\n    let [propertyName, {\n      original,\n      wrapped\n    }] = _ref8;\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};","map":{"version":3,"names":["_extends","React","gridAggregationLookupSelector","GridFooterCell","GridAggregationHeader","jsx","_jsx","AGGREGATION_WRAPPABLE_PROPERTIES","getAggregationValueWrappedValueGetter","_ref","value","valueGetter","getCellAggregationResult","wrappedValueGetter","params","cellAggregationResult","id","field","_cellAggregationResul","row","getAggregationValueWrappedValueFormatter","_ref2","valueFormatter","aggregationRule","aggregationFunction","wrappedValueFormatter","getAggregationValueWrappedRenderCell","_ref3","renderCell","wrappedRenderCell","_aggregationFunction$","position","formattedValue","aggregationMeta","hasCellUnit","aggregationFunctionName","aggregation","getWrappedFilterOperators","_ref4","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","getWrappedRenderHeader","_ref5","renderHeader","wrapColumnWithAggregationValue","_ref6","apiRef","_rowNode$parent","_gridAggregationLooku","_gridAggregationLooku2","cellAggregationPosition","rowNode","current","getRowNode","type","toString","startsWith","groupId","parent","aggregationResult","aggregationWrappedProperties","wrappedColumn","wrapColumnProperty","property","wrapper","originalValue","wrappedProperty","colDef","original","wrapped","Object","keys","length","unwrapColumnFromAggregation","_ref7","originalProperties","entries","unwrappedColumn","forEach","_ref8","propertyName"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/wrapColumnWithAggregation.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n    return params.row[params.field];\n  };\n  return wrappedValueGetter;\n};\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n    return params.value;\n  };\n  return wrappedValueFormatter;\n};\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n        return params.formattedValue;\n      }\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n    return renderCell(params);\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Skips the filtering for aggregated rows\n */\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  return _extends({}, operator, {\n    getApplyFilterFn: (filterItem, column) => {\n      const originalFn = operator.getApplyFilterFn(filterItem, column);\n      if (!originalFn) {\n        return null;\n      }\n      return params => {\n        if (getCellAggregationResult(params.id, params.field) != null) {\n          return true;\n        }\n        return originalFn(params);\n      };\n    }\n  });\n});\n\n/**\n * Add the aggregation method around the header name\n */\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n  return wrappedRenderCell;\n};\n\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\nexport const wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$parent, _gridAggregationLooku, _gridAggregationLooku2;\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n    if (rowNode.type === 'group') {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n    if (cellAggregationPosition == null) {\n      return null;\n    }\n\n    // TODO: Add custom root id\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)) == null ? void 0 : (_gridAggregationLooku2 = _gridAggregationLooku[groupId]) == null ? void 0 : _gridAggregationLooku2[field];\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n    return aggregationResult;\n  };\n  const aggregationWrappedProperties = {};\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n  return wrappedColumn;\n};\n\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\nexport const unwrapColumnFromAggregation = ({\n  column\n}) => {\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n  if (originalProperties.length === 0) {\n    return column;\n  }\n  const unwrappedColumn = _extends({}, column);\n  originalProperties.forEach(([propertyName, {\n    original,\n    wrapped\n  }]) => {\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}