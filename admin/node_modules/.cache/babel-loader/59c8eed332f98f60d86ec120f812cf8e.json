{"ast":null,"code":"import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowTreeSelector, GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\nconst getAggregationCellValue = _ref => {\n  let {\n    apiRef,\n    groupId,\n    field,\n    aggregationFunction,\n    aggregationRowsScope\n  } = _ref;\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const rowIds = apiRef.current.getRowGroupChildren({\n    groupId\n  });\n  const values = [];\n  rowIds.forEach(rowId => {\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    }\n\n    // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n    const rowNode = apiRef.current.getRowNode(rowId);\n    if (rowNode.type === 'group') {\n      return;\n    }\n    if (typeof aggregationFunction.getCellValue === 'function') {\n      const row = apiRef.current.getRow(rowId);\n      values.push(aggregationFunction.getCellValue({\n        row\n      }));\n    } else {\n      values.push(apiRef.current.getCellValue(rowId, field));\n    }\n  });\n  return aggregationFunction.apply({\n    values,\n    groupId,\n    field // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455\n  });\n};\n\nconst getGroupAggregatedValue = _ref2 => {\n  let {\n    groupId,\n    apiRef,\n    aggregationRowsScope,\n    aggregatedFields,\n    aggregationRules,\n    position\n  } = _ref2;\n  const groupAggregationLookup = {};\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n  return groupAggregationLookup;\n};\nexport const createAggregationLookup = _ref3 => {\n  let {\n    apiRef,\n    aggregationFunctions,\n    aggregationRowsScope,\n    getAggregationPosition\n  } = _ref3;\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n  const aggregationLookup = {};\n  const rowTree = gridRowTreeSelector(apiRef);\n  const createGroupAggregationLookup = groupNode => {\n    for (let i = 0; i < groupNode.children.length; i += 1) {\n      const childId = groupNode.children[i];\n      const childNode = rowTree[childId];\n      if (childNode.type === 'group') {\n        createGroupAggregationLookup(childNode);\n      }\n    }\n    const hasAggregableChildren = groupNode.children.length;\n    if (hasAggregableChildren) {\n      const position = getAggregationPosition(groupNode);\n      if (position != null) {\n        aggregationLookup[groupNode.id] = getGroupAggregatedValue({\n          groupId: groupNode.id,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  };\n  createGroupAggregationLookup(rowTree[GRID_ROOT_GROUP_ID]);\n  return aggregationLookup;\n};","map":{"version":3,"names":["gridColumnLookupSelector","gridFilteredRowsLookupSelector","gridRowTreeSelector","GRID_ROOT_GROUP_ID","getAggregationRules","gridAggregationModelSelector","getAggregationCellValue","_ref","apiRef","groupId","field","aggregationFunction","aggregationRowsScope","filteredRowsLookup","rowIds","current","getRowGroupChildren","values","forEach","rowId","rowNode","getRowNode","type","getCellValue","row","getRow","push","apply","getGroupAggregatedValue","_ref2","aggregatedFields","aggregationRules","position","groupAggregationLookup","j","length","aggregatedField","columnAggregationRules","value","createAggregationLookup","_ref3","aggregationFunctions","getAggregationPosition","columnsLookup","aggregationModel","Object","keys","aggregationLookup","rowTree","createGroupAggregationLookup","groupNode","i","children","childId","childNode","hasAggregableChildren","id"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/createAggregationLookup.js"],"sourcesContent":["import { gridColumnLookupSelector, gridFilteredRowsLookupSelector, gridRowTreeSelector, GRID_ROOT_GROUP_ID } from '@mui/x-data-grid-pro';\nimport { getAggregationRules } from './gridAggregationUtils';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\nconst getAggregationCellValue = ({\n  apiRef,\n  groupId,\n  field,\n  aggregationFunction,\n  aggregationRowsScope\n}) => {\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const rowIds = apiRef.current.getRowGroupChildren({\n    groupId\n  });\n  const values = [];\n  rowIds.forEach(rowId => {\n    if (aggregationRowsScope === 'filtered' && filteredRowsLookup[rowId] === false) {\n      return;\n    }\n\n    // If the row is a group, we want to aggregate based on its children\n    // For instance in the following tree, we want the aggregated values of A to be based on A.A, A.B.A and A.B.B but not A.B\n    // A\n    //   A.A\n    //   A.B\n    //     A.B.A\n    //     A.B.B\n    const rowNode = apiRef.current.getRowNode(rowId);\n    if (rowNode.type === 'group') {\n      return;\n    }\n    if (typeof aggregationFunction.getCellValue === 'function') {\n      const row = apiRef.current.getRow(rowId);\n      values.push(aggregationFunction.getCellValue({\n        row\n      }));\n    } else {\n      values.push(apiRef.current.getCellValue(rowId, field));\n    }\n  });\n  return aggregationFunction.apply({\n    values,\n    groupId,\n    field // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455\n  });\n};\n\nconst getGroupAggregatedValue = ({\n  groupId,\n  apiRef,\n  aggregationRowsScope,\n  aggregatedFields,\n  aggregationRules,\n  position\n}) => {\n  const groupAggregationLookup = {};\n  for (let j = 0; j < aggregatedFields.length; j += 1) {\n    const aggregatedField = aggregatedFields[j];\n    const columnAggregationRules = aggregationRules[aggregatedField];\n    groupAggregationLookup[aggregatedField] = {\n      position,\n      value: getAggregationCellValue({\n        apiRef,\n        groupId,\n        field: aggregatedField,\n        aggregationFunction: columnAggregationRules.aggregationFunction,\n        aggregationRowsScope\n      })\n    };\n  }\n  return groupAggregationLookup;\n};\nexport const createAggregationLookup = ({\n  apiRef,\n  aggregationFunctions,\n  aggregationRowsScope,\n  getAggregationPosition\n}) => {\n  const aggregationRules = getAggregationRules({\n    columnsLookup: gridColumnLookupSelector(apiRef),\n    aggregationModel: gridAggregationModelSelector(apiRef),\n    aggregationFunctions\n  });\n  const aggregatedFields = Object.keys(aggregationRules);\n  if (aggregatedFields.length === 0) {\n    return {};\n  }\n  const aggregationLookup = {};\n  const rowTree = gridRowTreeSelector(apiRef);\n  const createGroupAggregationLookup = groupNode => {\n    for (let i = 0; i < groupNode.children.length; i += 1) {\n      const childId = groupNode.children[i];\n      const childNode = rowTree[childId];\n      if (childNode.type === 'group') {\n        createGroupAggregationLookup(childNode);\n      }\n    }\n    const hasAggregableChildren = groupNode.children.length;\n    if (hasAggregableChildren) {\n      const position = getAggregationPosition(groupNode);\n      if (position != null) {\n        aggregationLookup[groupNode.id] = getGroupAggregatedValue({\n          groupId: groupNode.id,\n          apiRef,\n          aggregatedFields,\n          aggregationRowsScope,\n          aggregationRules,\n          position\n        });\n      }\n    }\n  };\n  createGroupAggregationLookup(rowTree[GRID_ROOT_GROUP_ID]);\n  return aggregationLookup;\n};"],"mappings":"AAAA,SAASA,wBAAwB,EAAEC,8BAA8B,EAAEC,mBAAmB,EAAEC,kBAAkB,QAAQ,sBAAsB;AACxI,SAASC,mBAAmB,QAAQ,wBAAwB;AAC5D,SAASC,4BAA4B,QAAQ,4BAA4B;AACzE,MAAMC,uBAAuB,GAAGC,IAAA,IAM1B;EAAA,IAN2B;IAC/BC,MAAM;IACNC,OAAO;IACPC,KAAK;IACLC,mBAAmB;IACnBC;EACF,CAAC,GAAAL,IAAA;EACC,MAAMM,kBAAkB,GAAGZ,8BAA8B,CAACO,MAAM,CAAC;EACjE,MAAMM,MAAM,GAAGN,MAAM,CAACO,OAAO,CAACC,mBAAmB,CAAC;IAChDP;EACF,CAAC,CAAC;EACF,MAAMQ,MAAM,GAAG,EAAE;EACjBH,MAAM,CAACI,OAAO,CAACC,KAAK,IAAI;IACtB,IAAIP,oBAAoB,KAAK,UAAU,IAAIC,kBAAkB,CAACM,KAAK,CAAC,KAAK,KAAK,EAAE;MAC9E;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMC,OAAO,GAAGZ,MAAM,CAACO,OAAO,CAACM,UAAU,CAACF,KAAK,CAAC;IAChD,IAAIC,OAAO,CAACE,IAAI,KAAK,OAAO,EAAE;MAC5B;IACF;IACA,IAAI,OAAOX,mBAAmB,CAACY,YAAY,KAAK,UAAU,EAAE;MAC1D,MAAMC,GAAG,GAAGhB,MAAM,CAACO,OAAO,CAACU,MAAM,CAACN,KAAK,CAAC;MACxCF,MAAM,CAACS,IAAI,CAACf,mBAAmB,CAACY,YAAY,CAAC;QAC3CC;MACF,CAAC,CAAC,CAAC;IACL,CAAC,MAAM;MACLP,MAAM,CAACS,IAAI,CAAClB,MAAM,CAACO,OAAO,CAACQ,YAAY,CAACJ,KAAK,EAAET,KAAK,CAAC,CAAC;IACxD;EACF,CAAC,CAAC;EACF,OAAOC,mBAAmB,CAACgB,KAAK,CAAC;IAC/BV,MAAM;IACNR,OAAO;IACPC,KAAK,CAAC;EACR,CAAC,CAAC;AACJ,CAAC;;AAED,MAAMkB,uBAAuB,GAAGC,KAAA,IAO1B;EAAA,IAP2B;IAC/BpB,OAAO;IACPD,MAAM;IACNI,oBAAoB;IACpBkB,gBAAgB;IAChBC,gBAAgB;IAChBC;EACF,CAAC,GAAAH,KAAA;EACC,MAAMI,sBAAsB,GAAG,CAAC,CAAC;EACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,gBAAgB,CAACK,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACnD,MAAME,eAAe,GAAGN,gBAAgB,CAACI,CAAC,CAAC;IAC3C,MAAMG,sBAAsB,GAAGN,gBAAgB,CAACK,eAAe,CAAC;IAChEH,sBAAsB,CAACG,eAAe,CAAC,GAAG;MACxCJ,QAAQ;MACRM,KAAK,EAAEhC,uBAAuB,CAAC;QAC7BE,MAAM;QACNC,OAAO;QACPC,KAAK,EAAE0B,eAAe;QACtBzB,mBAAmB,EAAE0B,sBAAsB,CAAC1B,mBAAmB;QAC/DC;MACF,CAAC;IACH,CAAC;EACH;EACA,OAAOqB,sBAAsB;AAC/B,CAAC;AACD,OAAO,MAAMM,uBAAuB,GAAGC,KAAA,IAKjC;EAAA,IALkC;IACtChC,MAAM;IACNiC,oBAAoB;IACpB7B,oBAAoB;IACpB8B;EACF,CAAC,GAAAF,KAAA;EACC,MAAMT,gBAAgB,GAAG3B,mBAAmB,CAAC;IAC3CuC,aAAa,EAAE3C,wBAAwB,CAACQ,MAAM,CAAC;IAC/CoC,gBAAgB,EAAEvC,4BAA4B,CAACG,MAAM,CAAC;IACtDiC;EACF,CAAC,CAAC;EACF,MAAMX,gBAAgB,GAAGe,MAAM,CAACC,IAAI,CAACf,gBAAgB,CAAC;EACtD,IAAID,gBAAgB,CAACK,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO,CAAC,CAAC;EACX;EACA,MAAMY,iBAAiB,GAAG,CAAC,CAAC;EAC5B,MAAMC,OAAO,GAAG9C,mBAAmB,CAACM,MAAM,CAAC;EAC3C,MAAMyC,4BAA4B,GAAGC,SAAS,IAAI;IAChD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACE,QAAQ,CAACjB,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;MACrD,MAAME,OAAO,GAAGH,SAAS,CAACE,QAAQ,CAACD,CAAC,CAAC;MACrC,MAAMG,SAAS,GAAGN,OAAO,CAACK,OAAO,CAAC;MAClC,IAAIC,SAAS,CAAChC,IAAI,KAAK,OAAO,EAAE;QAC9B2B,4BAA4B,CAACK,SAAS,CAAC;MACzC;IACF;IACA,MAAMC,qBAAqB,GAAGL,SAAS,CAACE,QAAQ,CAACjB,MAAM;IACvD,IAAIoB,qBAAqB,EAAE;MACzB,MAAMvB,QAAQ,GAAGU,sBAAsB,CAACQ,SAAS,CAAC;MAClD,IAAIlB,QAAQ,IAAI,IAAI,EAAE;QACpBe,iBAAiB,CAACG,SAAS,CAACM,EAAE,CAAC,GAAG5B,uBAAuB,CAAC;UACxDnB,OAAO,EAAEyC,SAAS,CAACM,EAAE;UACrBhD,MAAM;UACNsB,gBAAgB;UAChBlB,oBAAoB;UACpBmB,gBAAgB;UAChBC;QACF,CAAC,CAAC;MACJ;IACF;EACF,CAAC;EACDiB,4BAA4B,CAACD,OAAO,CAAC7C,kBAAkB,CAAC,CAAC;EACzD,OAAO4C,iBAAiB;AAC1B,CAAC"},"metadata":{},"sourceType":"module"}