{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = _ref2 => {\n  let {\n    id,\n    tree\n  } = _ref2;\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKeyName = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    const groupingField = (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingFieldName];\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = _ref3 => {\n  let {\n    node,\n    tree,\n    treeDepths\n  } = _ref3;\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2, _parentNode$childrenF2, _parentNode$childrenF3;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n    const _ref = (_parentNode$childrenF2 = (_parentNode$childrenF3 = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF3[groupingField]) != null ? _parentNode$childrenF2 : {},\n      _groupingKey$toString = groupingKey.toString(),\n      newChildrenFromPathWithField = _objectWithoutPropertiesLoose(_ref, [_groupingKey$toString].map(_toPropertyKey));\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = _extends({}, parentNode.childrenFromPath);\n    if (Object.keys(newChildrenFromPathWithField).length === 0) {\n      delete childrenFromPath[groupingField];\n    } else {\n      childrenFromPath[groupingField] = newChildrenFromPathWithField;\n    }\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = _ref4 => {\n  let {\n    node,\n    updatedNode,\n    previousTree,\n    tree,\n    treeDepths\n  } = _ref4;\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});\nexport const getVisibleRowsLookup = _ref5 => {\n  let {\n    tree,\n    filteredRowsLookup\n  } = _ref5;\n  if (!filteredRowsLookup) {\n    return {};\n  }\n  const visibleRowsLookup = {};\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n\n    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n  const nodes = Object.values(tree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n  return visibleRowsLookup;\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_toPropertyKey","_extends","GRID_ROOT_GROUP_ID","getGroupRowIdFromPath","path","pathStr","map","groupingCriteria","field","key","join","getNodePathInTree","_ref2","id","tree","node","push","type","groupingField","groupingKey","parent","reverse","updateGroupDefaultExpansion","defaultGroupingExpansionDepth","isGroupExpandedByDefault","childrenExpanded","depth","insertNodeInTree","treeDepths","previousTree","_treeDepths$node$dept","parentNode","_groupingField","_groupingKey","_parentNode$childrenF","groupingFieldName","groupingKeyName","childrenFromPath","children","toString","footerId","removeNodeFromTree","_ref3","nodeDepth","currentNodeCount","_groupingField2","_groupingKey2","_parentNode$childrenF2","_parentNode$childrenF3","_ref","_groupingKey$toString","newChildrenFromPathWithField","filter","childId","Object","keys","length","updateGroupNodeIdAndAutoGenerated","_ref4","updatedNode","forEach","groupNode","createUpdatedGroupsManager","value","addAction","groupId","action","getVisibleRowsLookup","_ref5","filteredRowsLookup","visibleRowsLookup","handleTreeNode","areAncestorsExpanded","isPassingFiltering","childNode","nodes","values","i"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/node_modules/@mui/x-data-grid-pro/utils/tree/utils.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = ({\n  id,\n  tree\n}) => {\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const updateGroupDefaultExpansion = (node, defaultGroupingExpansionDepth, isGroupExpandedByDefault) => {\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  node.childrenExpanded = childrenExpanded;\n  return node;\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = (node, tree, treeDepths, previousTree) => {\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingFieldName = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKeyName = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    const groupingField = (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingFieldName];\n    if (previousTree !== null && previousTree[parentNode.id] === tree[parentNode.id]) {\n      parentNode.children = [...parentNode.children, node.id];\n    } else {\n      parentNode.children.push(node.id);\n    }\n    if (groupingField == null) {\n      parentNode.childrenFromPath[groupingFieldName] = {\n        [groupingKeyName.toString()]: node.id\n      };\n    } else {\n      groupingField[groupingKeyName.toString()] = node.id;\n    }\n  } else if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    parentNode.footerId = node.id;\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2, _parentNode$childrenF2, _parentNode$childrenF3;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n    const _ref = (_parentNode$childrenF2 = (_parentNode$childrenF3 = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF3[groupingField]) != null ? _parentNode$childrenF2 : {},\n      _groupingKey$toString = groupingKey.toString(),\n      newChildrenFromPathWithField = _objectWithoutPropertiesLoose(_ref, [_groupingKey$toString].map(_toPropertyKey));\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = _extends({}, parentNode.childrenFromPath);\n    if (Object.keys(newChildrenFromPathWithField).length === 0) {\n      delete childrenFromPath[groupingField];\n    } else {\n      childrenFromPath[groupingField] = newChildrenFromPathWithField;\n    }\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = ({\n  node,\n  updatedNode,\n  previousTree,\n  tree,\n  treeDepths\n}) => {\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree(groupNode, tree, treeDepths, previousTree);\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});\nexport const getVisibleRowsLookup = ({\n  tree,\n  filteredRowsLookup\n}) => {\n  if (!filteredRowsLookup) {\n    return {};\n  }\n  const visibleRowsLookup = {};\n  const handleTreeNode = (node, areAncestorsExpanded) => {\n    const isPassingFiltering = filteredRowsLookup[node.id];\n    if (node.type === 'group') {\n      node.children.forEach(childId => {\n        const childNode = tree[childId];\n        handleTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded);\n      });\n    }\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n\n    // TODO rows v6: Should we keep storing the visibility status of footer independently or rely on the group visibility in the selector ?\n    if (node.type === 'group' && node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n  };\n  const nodes = Object.values(tree);\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    if (node.depth === 0) {\n      handleTreeNode(node, true);\n    }\n  }\n  return visibleRowsLookup;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}