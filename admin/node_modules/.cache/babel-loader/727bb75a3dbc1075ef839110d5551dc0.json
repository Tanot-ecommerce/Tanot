{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { insertNodeInTree } from '../../../utils/tree/utils';\nexport function addPinnedRow(_ref) {\n  let {\n    groupingParams,\n    rowModel,\n    rowId,\n    position,\n    apiRef,\n    isAutoGenerated\n  } = _ref;\n  var _groupingParams$addit, _groupingParams$addit2, _groupingParams$addit3, _groupingParams$addit4;\n  const dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);\n  const tree = _extends({}, groupingParams.tree);\n  const treeDepths = _extends({}, groupingParams.treeDepths);\n\n  // TODO: warn if id is already present in `props.rows`\n\n  const node = {\n    type: 'pinnedRow',\n    id: rowId,\n    depth: 0,\n    parent: GRID_ROOT_GROUP_ID,\n    isAutoGenerated\n  };\n  insertNodeInTree(node, tree, treeDepths, null);\n  if (!isAutoGenerated) {\n    dataRowIdToModelLookup[rowId] = rowModel;\n    dataRowIdToIdLookup[rowId] = rowId;\n  }\n  // Do not push it to ids list so that pagination is not affected by pinned rows\n\n  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;\n  const previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  if ((_groupingParams$addit2 = groupingParams.additionalRowGroups) != null && (_groupingParams$addit3 = _groupingParams$addit2.pinnedRows) != null && (_groupingParams$addit4 = _groupingParams$addit3[position]) != null && _groupingParams$addit4.includes(newPinnedRow)) {\n    return _extends({}, groupingParams, {\n      dataRowIdToModelLookup,\n      dataRowIdToIdLookup,\n      tree,\n      treeDepths\n    });\n  }\n  return _extends({}, groupingParams, {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    tree,\n    treeDepths,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    var _pinnedRowsCache$topI, _pinnedRowsCache$bott, _pinnedRowsCache$bott2, _pinnedRowsCache$topI2;\n    const pinnedRowsCache = apiRef.current.caches.pinnedRows || {};\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n\n    // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children\n    if ((_pinnedRowsCache$bott2 = pinnedRowsCache.bottomIds) != null && _pinnedRowsCache$bott2.length || (_pinnedRowsCache$topI2 = pinnedRowsCache.topIds) != null && _pinnedRowsCache$topI2.length) {\n      const shouldKeepRow = rowId => {\n        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {\n          return false;\n        }\n        return true;\n      };\n      const rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];\n      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {\n        children: rootGroupNode.children.filter(shouldKeepRow)\n      });\n      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);\n    }\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};","map":{"version":3,"names":["_extends","React","useGridRegisterPipeProcessor","GRID_ROOT_GROUP_ID","insertNodeInTree","addPinnedRow","_ref","groupingParams","rowModel","rowId","position","apiRef","isAutoGenerated","_groupingParams$addit","_groupingParams$addit2","_groupingParams$addit3","_groupingParams$addit4","dataRowIdToModelLookup","dataRowIdToIdLookup","tree","treeDepths","node","type","id","depth","parent","current","caches","rows","previousPinnedRows","additionalRowGroups","pinnedRows","newPinnedRow","model","includes","useGridRowPinningPreProcessors","addPinnedRows","useCallback","_pinnedRowsCache$topI","_pinnedRowsCache$bott","_pinnedRowsCache$bott2","_pinnedRowsCache$topI2","pinnedRowsCache","newGroupingParams","topIds","forEach","idLookup","bottomIds","length","shouldKeepRow","rootGroupNode","children","filter","dataRowIds"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/node_modules/@mui/x-data-grid-pro/hooks/features/rowPinning/useGridRowPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { insertNodeInTree } from '../../../utils/tree/utils';\nexport function addPinnedRow({\n  groupingParams,\n  rowModel,\n  rowId,\n  position,\n  apiRef,\n  isAutoGenerated\n}) {\n  var _groupingParams$addit, _groupingParams$addit2, _groupingParams$addit3, _groupingParams$addit4;\n  const dataRowIdToModelLookup = _extends({}, groupingParams.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, groupingParams.dataRowIdToIdLookup);\n  const tree = _extends({}, groupingParams.tree);\n  const treeDepths = _extends({}, groupingParams.treeDepths);\n\n  // TODO: warn if id is already present in `props.rows`\n\n  const node = {\n    type: 'pinnedRow',\n    id: rowId,\n    depth: 0,\n    parent: GRID_ROOT_GROUP_ID,\n    isAutoGenerated\n  };\n  insertNodeInTree(node, tree, treeDepths, null);\n  if (!isAutoGenerated) {\n    dataRowIdToModelLookup[rowId] = rowModel;\n    dataRowIdToIdLookup[rowId] = rowId;\n  }\n  // Do not push it to ids list so that pagination is not affected by pinned rows\n\n  apiRef.current.caches.rows.dataRowIdToModelLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.caches.rows.dataRowIdToIdLookup[rowId] = rowId;\n  const previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  if ((_groupingParams$addit2 = groupingParams.additionalRowGroups) != null && (_groupingParams$addit3 = _groupingParams$addit2.pinnedRows) != null && (_groupingParams$addit4 = _groupingParams$addit3[position]) != null && _groupingParams$addit4.includes(newPinnedRow)) {\n    return _extends({}, groupingParams, {\n      dataRowIdToModelLookup,\n      dataRowIdToIdLookup,\n      tree,\n      treeDepths\n    });\n  }\n  return _extends({}, groupingParams, {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    tree,\n    treeDepths,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    var _pinnedRowsCache$topI, _pinnedRowsCache$bott, _pinnedRowsCache$bott2, _pinnedRowsCache$topI2;\n    const pinnedRowsCache = apiRef.current.caches.pinnedRows || {};\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef,\n        isAutoGenerated: false\n      });\n    });\n\n    // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from the root group children\n    if ((_pinnedRowsCache$bott2 = pinnedRowsCache.bottomIds) != null && _pinnedRowsCache$bott2.length || (_pinnedRowsCache$topI2 = pinnedRowsCache.topIds) != null && _pinnedRowsCache$topI2.length) {\n      const shouldKeepRow = rowId => {\n        if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].type === 'pinnedRow') {\n          return false;\n        }\n        return true;\n      };\n      const rootGroupNode = newGroupingParams.tree[GRID_ROOT_GROUP_ID];\n      newGroupingParams.tree[GRID_ROOT_GROUP_ID] = _extends({}, rootGroupNode, {\n        children: rootGroupNode.children.filter(shouldKeepRow)\n      });\n      newGroupingParams.dataRowIds = newGroupingParams.dataRowIds.filter(shouldKeepRow);\n    }\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}