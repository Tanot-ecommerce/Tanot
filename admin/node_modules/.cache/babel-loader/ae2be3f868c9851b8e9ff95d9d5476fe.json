{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = _ref => {\n  let {\n    id,\n    path,\n    updatedGroupsManager,\n    previousTree,\n    tree,\n    treeDepths,\n    onDuplicatePath,\n    isGroupExpandedByDefault,\n    defaultGroupingExpansionDepth\n  } = _ref;\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath, _childrenFromPath$fie;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null ? void 0 : (_childrenFromPath$fie = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath$fie[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","updateGroupDefaultExpansion","getGroupRowIdFromPath","insertNodeInTree","updateGroupNodeIdAndAutoGenerated","insertDataRowInTree","_ref","id","path","updatedGroupsManager","previousTree","tree","treeDepths","onDuplicatePath","isGroupExpandedByDefault","defaultGroupingExpansionDepth","parentNodeId","depth","length","_childrenFromPath","_childrenFromPath$fie","key","field","fieldWithDefaultValue","keyWithDefaultValue","existingNodeIdWithPartialPath","childrenFromPath","toString","leafNode","type","parent","groupingKey","addAction","existingNodeWithPartialPath","isAutoGenerated","node","updatedNode","nodeId","slice","autoGeneratedGroupNode","groupingField","children","childrenExpanded","currentGroupNode","groupNode"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/node_modules/@mui/x-data-grid-pro/utils/tree/insertDataRowInTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { updateGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  previousTree,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath, _childrenFromPath$fie;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null ? void 0 : (_childrenFromPath$fie = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath$fie[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree(leafNode, tree, treeDepths, previousTree);\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            previousTree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {},\n        childrenExpanded: false\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree(updateGroupDefaultExpansion(autoGeneratedGroupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault), tree, treeDepths, previousTree);\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {},\n          childrenExpanded: false\n        };\n        tree[existingNodeIdWithPartialPath] = updateGroupDefaultExpansion(groupNode, defaultGroupingExpansionDepth, isGroupExpandedByDefault);\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}