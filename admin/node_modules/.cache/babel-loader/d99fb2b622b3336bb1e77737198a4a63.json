{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  var _groupingField, _groupingField2;\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = (_groupingField = cellParams1.rowNode.groupingField) != null ? _groupingField : null;\n  const groupingField2 = (_groupingField2 = cellParams2.rowNode.groupingField) != null ? _groupingField2 : null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n        if (!originalFn) {\n          return null;\n        }\n        return params => {\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.type === 'group' && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n        if (!originalFn) {\n          return null;\n        }\n        return params => {\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n  var _groupedByColDef$widt, _leafColDef$width;\n  const _ref = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n  var _leafColDef$width2;\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      return params.rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_extends","_excluded","_excluded2","React","GRID_STRING_COL_DEF","isSingleSelectColDef","GridGroupingColumnFooterCell","GridGroupingCriteriaCell","GridGroupingColumnLeafCell","getRowGroupingFieldFromGroupingCriteria","GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD","gridRowGroupingSanitizedModelSelector","jsx","_jsx","GROUPING_COL_DEF_DEFAULT_PROPERTIES","disableReorder","GROUPING_COL_DEF_FORCED_PROPERTIES","type","editable","groupable","groupingFieldIndexComparator","v1","v2","cellParams1","cellParams2","_groupingField","_groupingField2","model","api","state","instanceId","groupingField1","rowNode","groupingField","groupingField2","indexOf","getLeafProperties","leafColDef","_leafColDef$headerNam","_leafColDef$filterOpe","headerName","field","sortable","filterable","valueOptions","undefined","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","params","sortComparator","getGroupingCriteriaProperties","groupedByColDef","applyHeaderName","_groupedByColDef$filt","properties","_groupedByColDef$head","createGroupingColDefForOneGroupingCriteria","_ref3","columnsLookup","groupingCriteria","colDefOverride","_groupedByColDef$widt","_leafColDef$width","_ref","leafField","mainGroupingCriteria","hideDescendantCount","colDefOverrideProperties","commonProperties","width","Math","max","renderCell","leafParams","getCellParams","id","hasFocus","valueGetter","getCellValue","groupingKey","sourceProperties","forcedProperties","createGroupingColDefForAllGroupingCriteria","_ref4","apiRef","rowGroupingModel","_leafColDef$width2","_ref2","current","getLocaleText","_columnsLookup$field$","includes","length"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/hooks/features/rowGrouping/createGroupingColDef.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n  _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { isSingleSelectColDef } from '@mui/x-data-grid-pro/internals';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  var _groupingField, _groupingField2;\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = (_groupingField = cellParams1.rowNode.groupingField) != null ? _groupingField : null;\n  const groupingField2 = (_groupingField2 = cellParams2.rowNode.groupingField) != null ? _groupingField2 : null;\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n  if (groupingField1 == null) {\n    return -1;\n  }\n  if (groupingField2 == null) {\n    return 1;\n  }\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n  return 1;\n};\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    valueOptions: isSingleSelectColDef(leafColDef) ? leafColDef.valueOptions : undefined,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n        if (!originalFn) {\n          return null;\n        }\n        return params => {\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.type === 'leaf' && cellParams2.rowNode.type === 'leaf') {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    valueOptions: isSingleSelectColDef(groupedByColDef) ? groupedByColDef.valueOptions : undefined,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.type === 'group' && cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.type === 'group' && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n        if (!originalFn) {\n          return null;\n        }\n        return params => {\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\nexport const createGroupingColDefForOneGroupingCriteria = ({\n  columnsLookup,\n  groupedByColDef,\n  groupingCriteria,\n  colDefOverride\n}) => {\n  var _groupedByColDef$widt, _leafColDef$width;\n  const _ref = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render current grouping criteria groups\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n      return undefined;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n  let sourceProperties;\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\nexport const createGroupingColDefForAllGroupingCriteria = ({\n  apiRef,\n  columnsLookup,\n  rowGroupingModel,\n  colDefOverride\n}) => {\n  var _leafColDef$width2;\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n    {\n      leafField,\n      mainGroupingCriteria,\n      hideDescendantCount\n    } = _ref2,\n    colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const leafColDef = leafField ? columnsLookup[leafField] : null;\n\n  // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      }\n\n      // Render the leaves\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api,\n            hasFocus: params.hasFocus\n          });\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n        return '';\n      }\n\n      // Render the groups\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode || params.rowNode.type === 'footer' || params.rowNode.type === 'pinnedRow') {\n        return undefined;\n      }\n      if (params.rowNode.type === 'leaf') {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n        return undefined;\n      }\n      return params.rowNode.groupingKey;\n    }\n  };\n\n  // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n  let sourceProperties;\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  }\n\n  // The properties that can't be overridden with `colDefOverride`\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}