{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GRID_CHECKBOX_SELECTION_FIELD, gridFocusCellSelector, gridVisibleColumnFieldsSelector, useGridApiOptionHandler, useGridApiEventHandler, gridPaginatedVisibleSortedGridRowIdsSelector } from '@mui/x-data-grid';\nimport { buildWarning, getRowIdFromRowModel, getActiveElement, useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD, GRID_REORDER_COL_DEF } from '@mui/x-data-grid-pro';\nimport { unstable_debounce as debounce } from '@mui/utils';\nconst missingOnProcessRowUpdateErrorWarning = buildWarning(['MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [GRID_CHECKBOX_SELECTION_FIELD, GRID_REORDER_COL_DEF.field, GRID_DETAIL_PANEL_TOGGLE_FIELD];\n\n// Batches rows that are updated during clipboard paste to reduce `updateRows` calls\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = debounce(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = getActiveElement(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n    const handlePasteEvent = event => {\n      var _event$clipboardData;\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('text/plain');\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n      el.remove();\n      resolve(text || '');\n    };\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n}\n\n// Keeps track of updated rows during clipboard paste\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n  updateCell(_ref2) {\n    let {\n      rowId,\n      field,\n      pastedCellValue\n    } = _ref2;\n    if (pastedCellValue === undefined) {\n      return;\n    }\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n    const row = this.rowsToUpdate[rowId] || _extends({}, apiRef.current.getRow(rowId));\n    if (!row) {\n      return;\n    }\n    const cellParams = apiRef.current.getCellParams(rowId, field);\n    let parsedValue = pastedCellValue;\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, cellParams);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, cellParams);\n    }\n    if (parsedValue === undefined) {\n      return;\n    }\n    let rowCopy = _extends({}, row);\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter({\n        value: parsedValue,\n        row: rowCopy\n      });\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n    const newRowId = getRowIdFromRowModel(rowCopy, getRowId);\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n}\nfunction defaultPasteResolver(_ref3) {\n  let {\n    pastedData,\n    apiRef,\n    updateCell\n  } = _ref3;\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.unstable_getCellSelectionModel();\n  if (cellSelectionModel && apiRef.current.unstable_getSelectedCellsAsArray().length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n      if (!hasRowData) {\n        return;\n      }\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length;\n\n    // There's no guarantee that the selected rows are in the same order as the pasted rows\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n      if (rowData === undefined) {\n        return;\n      }\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n  const selectedCell = gridFocusCellSelector(apiRef);\n  if (!selectedCell) {\n    return;\n  }\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = gridPaginatedVisibleSortedGridRowIdsSelector(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\nfunction isPasteShortcut(event) {\n  return (event.ctrlKey || event.metaKey) && event.key === 'v';\n}\nexport const useGridClipboardImport = (apiRef, props) => {\n  var _ref, _props$experimentalFe, _apiRef$current$rootE;\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = (_ref = !props.disableClipboardPaste && ((_props$experimentalFe = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe.clipboardPaste)) != null ? _ref : false;\n  const rootEl = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;\n  const splitClipboardPastedText = props.unstable_splitClipboardPastedText;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n    if (!isPasteShortcut(event)) {\n      return;\n    }\n    const focusedCell = gridFocusCellSelector(apiRef);\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n    if (!rootEl) {\n      return;\n    }\n    const text = await getTextFromClipboard(rootEl);\n    if (!text) {\n      return;\n    }\n    const pastedData = splitClipboardPastedText(text);\n    if (!pastedData) {\n      return;\n    }\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: {\n        current: apiRef.current.getPublicApi()\n      },\n      updateCell: function () {\n        cellUpdater.updateCell(...arguments);\n      }\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, _ref4) => {\n    let {\n      event\n    } = _ref4;\n    if (isPasteShortcut(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n    return initialValue;\n  }, [enableClipboardPaste]);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handlePaste);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  useGridRegisterPipeProcessor(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};","map":{"version":3,"names":["_extends","React","GRID_CHECKBOX_SELECTION_FIELD","gridFocusCellSelector","gridVisibleColumnFieldsSelector","useGridApiOptionHandler","useGridApiEventHandler","gridPaginatedVisibleSortedGridRowIdsSelector","buildWarning","getRowIdFromRowModel","getActiveElement","useGridRegisterPipeProcessor","GRID_DETAIL_PANEL_TOGGLE_FIELD","GRID_REORDER_COL_DEF","unstable_debounce","debounce","missingOnProcessRowUpdateErrorWarning","columnFieldsToExcludeFromPaste","field","batchRowUpdates","func","wait","rows","debounced","row","push","getTextFromClipboard","rootEl","Promise","resolve","focusedCell","document","el","createElement","style","width","height","border","margin","padding","outline","position","top","left","handlePasteEvent","event","_event$clipboardData","removeEventListener","text","clipboardData","getData","HTMLElement","focus","preventScroll","remove","addEventListener","appendChild","CellValueUpdater","constructor","options","rowsToUpdate","updateRow","apiRef","current","updateRows","updateCell","_ref2","rowId","pastedCellValue","undefined","getRowId","colDef","getColumn","editable","getRow","cellParams","getCellParams","parsedValue","pastedValueParser","valueParser","rowCopy","valueSetter","value","newRowId","String","applyUpdates","processRowUpdate","onProcessRowUpdateError","rowIdsToUpdate","Object","keys","length","publishEvent","handleRowUpdate","newRow","handleError","errorThrown","oldRow","finalRowUpdate","error","promises","map","then","catch","all","defaultPasteResolver","_ref3","pastedData","isSingleValuePasted","cellSelectionModel","unstable_getCellSelectionModel","unstable_getSelectedCellsAsArray","forEach","rowIndex","rowDataArr","hasRowData","colIndex","cellValue","visibleColumnFields","filter","includes","selectedRows","getSelectedRows","size","pastedRowsDataCount","rowData","shift","newCellValue","cellIndex","selectedCell","selectedRowId","id","selectedRowIndex","getRowIndexRelativeToVisibleRows","visibleRowIds","selectedFieldIndex","indexOf","index","i","stringValue","isPasteShortcut","ctrlKey","metaKey","key","useGridClipboardImport","props","_ref","_props$experimentalFe","_apiRef$current$rootE","enableClipboardPaste","disableClipboardPaste","experimentalFeatures","clipboardPaste","rootElementRef","splitClipboardPastedText","unstable_splitClipboardPastedText","handlePaste","useCallback","params","cellMode","getCellMode","cellUpdater","data","getPublicApi","arguments","checkIfCanStartEditing","initialValue","_ref4","onClipboardPasteStart","onClipboardPasteEnd"],"sources":["D:/Tanot/admin/node_modules/@mui/x-data-grid-generator/node_modules/@mui/x-data-grid-premium/hooks/features/clipboard/useGridClipboardImport.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GRID_CHECKBOX_SELECTION_FIELD, gridFocusCellSelector, gridVisibleColumnFieldsSelector, useGridApiOptionHandler, useGridApiEventHandler, gridPaginatedVisibleSortedGridRowIdsSelector } from '@mui/x-data-grid';\nimport { buildWarning, getRowIdFromRowModel, getActiveElement, useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD, GRID_REORDER_COL_DEF } from '@mui/x-data-grid-pro';\nimport { unstable_debounce as debounce } from '@mui/utils';\nconst missingOnProcessRowUpdateErrorWarning = buildWarning(['MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.', 'To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.', 'For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence.'], 'error');\nconst columnFieldsToExcludeFromPaste = [GRID_CHECKBOX_SELECTION_FIELD, GRID_REORDER_COL_DEF.field, GRID_DETAIL_PANEL_TOGGLE_FIELD];\n\n// Batches rows that are updated during clipboard paste to reduce `updateRows` calls\nfunction batchRowUpdates(func, wait) {\n  let rows = [];\n  const debounced = debounce(() => {\n    func(rows);\n    rows = [];\n  }, wait);\n  return row => {\n    rows.push(row);\n    debounced();\n  };\n}\nasync function getTextFromClipboard(rootEl) {\n  return new Promise(resolve => {\n    const focusedCell = getActiveElement(document);\n    const el = document.createElement('input');\n    el.style.width = '0px';\n    el.style.height = '0px';\n    el.style.border = 'none';\n    el.style.margin = '0';\n    el.style.padding = '0';\n    el.style.outline = 'none';\n    el.style.position = 'absolute';\n    el.style.top = '0';\n    el.style.left = '0';\n    const handlePasteEvent = event => {\n      var _event$clipboardData;\n      el.removeEventListener('paste', handlePasteEvent);\n      const text = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('text/plain');\n      if (focusedCell instanceof HTMLElement) {\n        focusedCell.focus({\n          preventScroll: true\n        });\n      }\n      el.remove();\n      resolve(text || '');\n    };\n    el.addEventListener('paste', handlePasteEvent);\n    rootEl.appendChild(el);\n    el.focus({\n      preventScroll: true\n    });\n  });\n}\n\n// Keeps track of updated rows during clipboard paste\nclass CellValueUpdater {\n  constructor(options) {\n    this.rowsToUpdate = {};\n    this.updateRow = void 0;\n    this.options = void 0;\n    this.options = options;\n    this.updateRow = batchRowUpdates(options.apiRef.current.updateRows, 50);\n  }\n  updateCell({\n    rowId,\n    field,\n    pastedCellValue\n  }) {\n    if (pastedCellValue === undefined) {\n      return;\n    }\n    const {\n      apiRef,\n      getRowId\n    } = this.options;\n    const colDef = apiRef.current.getColumn(field);\n    if (!colDef || !colDef.editable) {\n      return;\n    }\n    const row = this.rowsToUpdate[rowId] || _extends({}, apiRef.current.getRow(rowId));\n    if (!row) {\n      return;\n    }\n    const cellParams = apiRef.current.getCellParams(rowId, field);\n    let parsedValue = pastedCellValue;\n    if (colDef.pastedValueParser) {\n      parsedValue = colDef.pastedValueParser(pastedCellValue, cellParams);\n    } else if (colDef.valueParser) {\n      parsedValue = colDef.valueParser(parsedValue, cellParams);\n    }\n    if (parsedValue === undefined) {\n      return;\n    }\n    let rowCopy = _extends({}, row);\n    if (typeof colDef.valueSetter === 'function') {\n      rowCopy = colDef.valueSetter({\n        value: parsedValue,\n        row: rowCopy\n      });\n    } else {\n      rowCopy[field] = parsedValue;\n    }\n    const newRowId = getRowIdFromRowModel(rowCopy, getRowId);\n    if (String(newRowId) !== String(rowId)) {\n      // We cannot update row id, so this cell value update should be ignored\n      return;\n    }\n    this.rowsToUpdate[rowId] = rowCopy;\n  }\n  applyUpdates() {\n    const {\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError\n    } = this.options;\n    const rowsToUpdate = this.rowsToUpdate;\n    const rowIdsToUpdate = Object.keys(rowsToUpdate);\n    if (rowIdsToUpdate.length === 0) {\n      apiRef.current.publishEvent('clipboardPasteEnd');\n      return;\n    }\n    const handleRowUpdate = async rowId => {\n      const newRow = rowsToUpdate[rowId];\n      if (typeof processRowUpdate === 'function') {\n        const handleError = errorThrown => {\n          if (onProcessRowUpdateError) {\n            onProcessRowUpdateError(errorThrown);\n          } else {\n            missingOnProcessRowUpdateErrorWarning();\n          }\n        };\n        try {\n          const oldRow = apiRef.current.getRow(rowId);\n          const finalRowUpdate = await processRowUpdate(newRow, oldRow);\n          this.updateRow(finalRowUpdate);\n        } catch (error) {\n          handleError(error);\n        }\n      } else {\n        this.updateRow(newRow);\n      }\n    };\n    const promises = rowIdsToUpdate.map(rowId => {\n      // Wrap in promise that always resolves to avoid Promise.all from stopping on first error.\n      // This is to avoid using `Promise.allSettled` that has worse browser support.\n      return new Promise(resolve => {\n        handleRowUpdate(rowId).then(resolve).catch(resolve);\n      });\n    });\n    Promise.all(promises).then(() => {\n      this.rowsToUpdate = {};\n      apiRef.current.publishEvent('clipboardPasteEnd');\n    });\n  }\n}\nfunction defaultPasteResolver({\n  pastedData,\n  apiRef,\n  updateCell\n}) {\n  const isSingleValuePasted = pastedData.length === 1 && pastedData[0].length === 1;\n  const cellSelectionModel = apiRef.current.unstable_getCellSelectionModel();\n  if (cellSelectionModel && apiRef.current.unstable_getSelectedCellsAsArray().length > 1) {\n    Object.keys(cellSelectionModel).forEach((rowId, rowIndex) => {\n      const rowDataArr = pastedData[isSingleValuePasted ? 0 : rowIndex];\n      const hasRowData = isSingleValuePasted ? true : rowDataArr !== undefined;\n      if (!hasRowData) {\n        return;\n      }\n      Object.keys(cellSelectionModel[rowId]).forEach((field, colIndex) => {\n        const cellValue = isSingleValuePasted ? rowDataArr[0] : rowDataArr[colIndex];\n        updateCell({\n          rowId,\n          field,\n          pastedCellValue: cellValue\n        });\n      });\n    });\n    return;\n  }\n  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef).filter(field => {\n    if (columnFieldsToExcludeFromPaste.includes(field)) {\n      return false;\n    }\n    return true;\n  });\n  const selectedRows = apiRef.current.getSelectedRows();\n  if (selectedRows.size > 0 && !isSingleValuePasted) {\n    // Multiple values are pasted starting from the first and top-most cell\n    const pastedRowsDataCount = pastedData.length;\n\n    // There's no guarantee that the selected rows are in the same order as the pasted rows\n    selectedRows.forEach((row, rowId) => {\n      let rowData;\n      if (pastedRowsDataCount === 1) {\n        // If only one row is pasted - paste it to all selected rows\n        rowData = pastedData[0];\n      } else {\n        rowData = pastedData.shift();\n      }\n      if (rowData === undefined) {\n        return;\n      }\n      rowData.forEach((newCellValue, cellIndex) => {\n        updateCell({\n          rowId,\n          field: visibleColumnFields[cellIndex],\n          pastedCellValue: newCellValue\n        });\n      });\n    });\n    return;\n  }\n  const selectedCell = gridFocusCellSelector(apiRef);\n  if (!selectedCell) {\n    return;\n  }\n  if (columnFieldsToExcludeFromPaste.includes(selectedCell.field)) {\n    return;\n  }\n  const selectedRowId = selectedCell.id;\n  const selectedRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(selectedRowId);\n  const visibleRowIds = gridPaginatedVisibleSortedGridRowIdsSelector(apiRef);\n  const selectedFieldIndex = visibleColumnFields.indexOf(selectedCell.field);\n  pastedData.forEach((rowData, index) => {\n    const rowId = visibleRowIds[selectedRowIndex + index];\n    if (typeof rowId === 'undefined') {\n      return;\n    }\n    for (let i = selectedFieldIndex; i < visibleColumnFields.length; i += 1) {\n      const field = visibleColumnFields[i];\n      const stringValue = rowData[i - selectedFieldIndex];\n      updateCell({\n        rowId,\n        field,\n        pastedCellValue: stringValue\n      });\n    }\n  });\n}\nfunction isPasteShortcut(event) {\n  return (event.ctrlKey || event.metaKey) && event.key === 'v';\n}\nexport const useGridClipboardImport = (apiRef, props) => {\n  var _ref, _props$experimentalFe, _apiRef$current$rootE;\n  const processRowUpdate = props.processRowUpdate;\n  const onProcessRowUpdateError = props.onProcessRowUpdateError;\n  const getRowId = props.getRowId;\n  const enableClipboardPaste = (_ref = !props.disableClipboardPaste && ((_props$experimentalFe = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe.clipboardPaste)) != null ? _ref : false;\n  const rootEl = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;\n  const splitClipboardPastedText = props.unstable_splitClipboardPastedText;\n  const handlePaste = React.useCallback(async (params, event) => {\n    if (!enableClipboardPaste) {\n      return;\n    }\n    if (!isPasteShortcut(event)) {\n      return;\n    }\n    const focusedCell = gridFocusCellSelector(apiRef);\n    if (focusedCell !== null) {\n      const cellMode = apiRef.current.getCellMode(focusedCell.id, focusedCell.field);\n      if (cellMode === 'edit') {\n        // Do not paste data when the cell is in edit mode\n        return;\n      }\n    }\n    if (!rootEl) {\n      return;\n    }\n    const text = await getTextFromClipboard(rootEl);\n    if (!text) {\n      return;\n    }\n    const pastedData = splitClipboardPastedText(text);\n    if (!pastedData) {\n      return;\n    }\n    const cellUpdater = new CellValueUpdater({\n      apiRef,\n      processRowUpdate,\n      onProcessRowUpdateError,\n      getRowId\n    });\n    apiRef.current.publishEvent('clipboardPasteStart', {\n      data: pastedData\n    });\n    defaultPasteResolver({\n      pastedData,\n      apiRef: {\n        current: apiRef.current.getPublicApi()\n      },\n      updateCell: (...args) => {\n        cellUpdater.updateCell(...args);\n      }\n    });\n    cellUpdater.applyUpdates();\n  }, [apiRef, processRowUpdate, onProcessRowUpdateError, getRowId, enableClipboardPaste, rootEl, splitClipboardPastedText]);\n  const checkIfCanStartEditing = React.useCallback((initialValue, {\n    event\n  }) => {\n    if (isPasteShortcut(event) && enableClipboardPaste) {\n      // Do not enter cell edit mode on paste\n      return false;\n    }\n    return initialValue;\n  }, [enableClipboardPaste]);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handlePaste);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteStart', props.onClipboardPasteStart);\n  useGridApiOptionHandler(apiRef, 'clipboardPasteEnd', props.onClipboardPasteEnd);\n  useGridRegisterPipeProcessor(apiRef, 'canStartEditing', checkIfCanStartEditing);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}